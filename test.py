from glob import glob
import os
import sys
import time
from collections import OrderedDict
import imageio
import numpy as np
from skimage.io import imread, imsave 
from hausdorff import hausdorff_distance
import logging

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms.functional as tf
import torch.utils.data as data
from torch.cuda import amp
import torch.backends.cudnn as cudnn

from tqdm import tqdm
import pickle
import pandas as pd

from metrics import *
from utils import *
from model import *
from dataset import *

def main():
    # testing is performed on the initially trained model for future comparison with the active learning and random learning model
    # in addition to ensuring the model is working as expected
    BATCH_SIZE = 32
    DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'

    # load the test set paths
    # these are lists containing paths to the slices selected for the test dataset as computed in the 'data_split.ipynb' file.
    # all MRI slices can be found in the 'all_data' folder
    TEST_IMG_DIR = pickle.load(open('data\\test\\img\\'+'test.data', 'rb'))
    TEST_LABEL_DIR = pickle.load(open('data\\test\\label\\'+'test.mask', 'rb'))

    logging.basicConfig(level=logging.INFO,                                         # instantiate a logger
                    format='%(asctime)s - %(levelname)s - %(message)s',
                    filename='base_test_results/base_test_output.txt',
                    filemode='w')
    
    console = logging.StreamHandler()                                               # define a new Handler to log to console as well
    console.setLevel(logging.INFO)                                                  # set the logging level
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')      # set a format which is the same for console use
    console.setFormatter(formatter)                                                 # tell the handler to use this format
    logging.getLogger('').addHandler(console)                                       # add the handler to the root logger

    test_img_paths =  TEST_IMG_DIR
    test_mask_paths = TEST_LABEL_DIR
    logging.info("test_num:%s"%str(len(test_img_paths)))

    # model, loss criteria, optimiser
    model = UNet2D(in_channels=4, out_channels=3).to(DEVICE) 
    logging.info("=> Creating 2D UNET Model")
    
    model.load_state_dict(torch.load('models/base_trained/2DUNET.pth'))
    model.eval()

    test_dataset = Dataset(test_img_paths, test_mask_paths)
    test_loader = torch.utils.data.DataLoader(
        test_dataset,
        batch_size=BATCH_SIZE,
        shuffle=False,
        pin_memory=True,
        drop_last=False)

    """
    obtain and save the label map generated by the model 
    """
    with torch.no_grad():
        for batch_idx, (data, labels) in tqdm(enumerate(test_loader), total=len(test_loader)):
            data = data.to(DEVICE) 
            
            preds = model(data)
            preds = torch.sigmoid(preds).data.cpu().numpy()
            
            img_paths = test_img_paths[BATCH_SIZE*batch_idx:BATCH_SIZE*(batch_idx+1)]

            for i in range(preds.shape[0]):
                npName = os.path.basename(img_paths[i])
                overNum = npName.find(".npy")
                rgbName = npName[0:overNum]
                rgbName = rgbName  + ".png"
                rgbPic = np.zeros([160, 160, 3], dtype=np.uint8)
                for idx in range(preds.shape[2]):
                    for idy in range(preds.shape[3]):
                        #(ED, peritumoral edema) (label 2) green
                        if preds[i,0,idx,idy] > 0.5: 
                            rgbPic[idx, idy, 0] = 0
                            rgbPic[idx, idy, 1] = 128
                            rgbPic[idx, idy, 2] = 0
                        #(NET, non-enhancing tumor)(label 1) red
                        if preds[i,1,idx,idy] > 0.5:
                            rgbPic[idx, idy, 0] = 255
                            rgbPic[idx, idy, 1] = 0
                            rgbPic[idx, idy, 2] = 0
                        #(ET, enhancing tumor)(label 4) yellow
                        if preds[i,2,idx,idy] > 0.5:
                            rgbPic[idx, idy, 0] = 255
                            rgbPic[idx, idy, 1] = 255
                            rgbPic[idx, idy, 2] = 0
                imsave('base_test_results/output/' + rgbName, rgbPic, check_contrast=False)

    torch.cuda.empty_cache()

    """
    convert the GT numpy format in the test set to a picture format and save 
    saving these will be useful for testing at each learning iteration during random or active learning
    """
    logging.info("Saving GT, numpy to picture")
    test_gt_path = 'base_test_results/output/' + 'GT/'
    if not os.path.exists(test_gt_path):
        os.mkdir(test_gt_path)
    for idx in tqdm(range(len(test_mask_paths))):
        mask_path = test_mask_paths[idx]
        name = os.path.basename(mask_path)
        overNum = name.find(".npy")
        name = name[0:overNum]
        rgbName = name + ".png"

        npmask = np.load(mask_path)

        GtColor = np.zeros([npmask.shape[0],npmask.shape[1],3], dtype=np.uint8)
        for idx in range(npmask.shape[0]):
            for idy in range(npmask.shape[1]):
                #(NET, non-enhancing tumor)(label 1) red
                if npmask[idx, idy] == 1:
                    GtColor[idx, idy, 0] = 255
                    GtColor[idx, idy, 1] = 0
                    GtColor[idx, idy, 2] = 0
                #(ED, peritumoral edema) (label 2) green
                elif npmask[idx, idy] == 2:
                    GtColor[idx, idy, 0] = 0
                    GtColor[idx, idy, 1] = 128
                    GtColor[idx, idy, 2] = 0
                #(ET, enhancing tumor)(label 4) yellow
                elif npmask[idx, idy] == 4:
                    GtColor[idx, idy, 0] = 255
                    GtColor[idx, idy, 1] = 255
                    GtColor[idx, idy, 2] = 0

        imageio.imwrite(test_gt_path + rgbName, GtColor)

    """
    calculate metrics: Dice, Precision, Recall, Hausdorff
    """
    wt_dices = []
    tc_dices = []
    et_dices = []
    wt_precision = []
    tc_precision = []
    et_precision = []
    wt_recall = []
    tc_recall = []
    et_recall = []
    wt_Hausdorff = []
    tc_Hausdorff = []
    et_Hausdorff = []

    maskPath = glob("base_test_results/output/" + "GT\*.png")
    pbPath = glob("base_test_results/output/" + "*.png")

    for myi in tqdm(range(len(maskPath))):
        mask = imread(maskPath[myi])
        pb = imread(pbPath[myi])

        wtmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        wtpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        tcmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        tcpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        etmaskregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)
        etpbregion = np.zeros([mask.shape[0], mask.shape[1]], dtype=np.float32)

        for idx in range(mask.shape[0]):
            for idy in range(mask.shape[1]):
                # As long as any channel of this pixel has a value, it means that this pixel does not belong to the foreground, that is, it belongs to the WT area 
                if mask[idx, idy, :].any() != 0:
                    wtmaskregion[idx, idy] = 1
                if pb[idx, idy, :].any() != 0:
                    wtpbregion[idx, idy] = 1
                # As long as the first channel is 255, it can be judged to be the TC area, because the first channel of red and yellow are both 255, which is different from green 
                if mask[idx, idy, 0] == 255:
                    tcmaskregion[idx, idy] = 1
                if pb[idx, idy, 0] == 255:
                    tcpbregion[idx, idy] = 1
                # As long as the second channel is 128, it can be judged to be the ET area 
                if mask[idx, idy, 1] == 128:
                    etmaskregion[idx, idy] = 1
                if pb[idx, idy, 1] == 128:
                    etpbregion[idx, idy] = 1

        #Start calculating WT - whole tumour
        dice = dice_coef(wtpbregion,wtmaskregion)
        wt_dices.append(dice)
        precision_n = precision(wtpbregion, wtmaskregion)
        wt_precision.append(precision_n)
        Hausdorff = hausdorff_distance(wtmaskregion, wtpbregion)
        wt_Hausdorff.append(Hausdorff)
        recall_n = recall(wtpbregion, wtmaskregion)
        wt_recall.append(recall_n)

        # Start calculating TC - tumour core
        dice = dice_coef(tcpbregion, tcmaskregion)
        tc_dices.append(dice)
        precision_n = precision(tcpbregion, tcmaskregion)
        tc_precision.append(precision_n)
        Hausdorff = hausdorff_distance(tcmaskregion, tcpbregion)
        tc_Hausdorff.append(Hausdorff)
        recall_n = recall(tcpbregion, tcmaskregion)
        tc_recall.append(recall_n)

        # Start calculating ET - enhancing tumour
        dice = dice_coef(etpbregion, etmaskregion)
        et_dices.append(dice)
        precision_n = precision(etpbregion, etmaskregion)
        et_precision.append(precision_n)
        Hausdorff = hausdorff_distance(etmaskregion, etpbregion)
        et_Hausdorff.append(Hausdorff)
        recall_n = recall(etpbregion, etmaskregion)
        et_recall.append(recall_n)

    logging.info('WT Dice: %.4f' % np.mean(wt_dices))
    logging.info('TC Dice: %.4f' % np.mean(tc_dices))
    logging.info('ET Dice: %.4f' % np.mean(et_dices))
    logging.info("=============")
    logging.info('WT Precision: %.4f' % np.mean(wt_precision))
    logging.info('TC Precision: %.4f' % np.mean(tc_precision))
    logging.info('ET Precision: %.4f' % np.mean(et_precision))
    logging.info("=============")
    logging.info('WT Recall: %.4f' % np.mean(wt_recall))
    logging.info('TC Recall: %.4f' % np.mean(tc_recall))
    logging.info('ET Recall: %.4f' % np.mean(et_recall))
    logging.info("=============")
    logging.info('WT Hausdorff: %.4f' % np.mean(wt_Hausdorff))
    logging.info('TC Hausdorff: %.4f' % np.mean(tc_Hausdorff))
    logging.info('ET Hausdorff: %.4f' % np.mean(et_Hausdorff))
    logging.info("=============")

    np.save('base_test_results' + '/mean_WT_dice.npy', np.mean(wt_dices)) 
    np.save('base_test_results' + '/mean_TC_dice.npy', np.mean(tc_dices)) 
    np.save('base_test_results' + '/mean_ET_dice.npy', np.mean(et_dices)) 
    np.save('base_test_results' + '/mean_WT_precision.npy', np.mean(wt_precision)) 
    np.save('base_test_results' + '/mean_TC_precision.npy', np.mean(tc_precision)) 
    np.save('base_test_results' + '/mean_ET_precision.npy', np.mean(et_precision)) 
    np.save('base_test_results' + '/mean_WT_recall.npy', np.mean(wt_recall)) 
    np.save('base_test_results' + '/mean_TC_recall.npy', np.mean(tc_recall)) 
    np.save('base_test_results' + '/mean_ET_recall.npy', np.mean(et_recall)) 
    np.save('base_test_results' + '/mean_WT_Hausdorff.npy', np.mean(wt_Hausdorff)) 
    np.save('base_test_results' + '/mean_TC_Hausdorff.npy', np.mean(tc_Hausdorff)) 
    np.save('base_test_results' + '/mean_ET_Hausdorff.npy', np.mean(et_Hausdorff)) 

if __name__ == '__main__':
    main()
